"""
DPA Translator - Bidirectional DPA ↔ DRAM Address Translation

This module provides translation between Device Physical Address (DPA)
and DRAM address components (rank, bank group, bank, row, column).
"""

import csv
import json
from typing import Dict, Optional, List, Tuple


class DPATranslator:
    """
    Bidirectional DPA ↔ DRAM address translation

    Forward:  DPA → (subch, dimm, rank, bg, ba, row, col)
    Reverse:  (rank, bg, ba, row, col, dimm, subch) → DPA

    The reverse translation is critical for implementing March algorithms
    that require sequential DRAM cell access.
    """

    def __init__(self, mapping_file: Optional[str] = None, mock_mode: bool = False):
        """
        Initialize DPA translator

        Args:
            mapping_file: CSV file containing DPA mapping data from umxc
                         (generated by dpa_mapping_collector.py)
            mock_mode: If True, use simplified mock translation rules
        """
        self.mock_mode = mock_mode
        self.mapping_data: List[Dict] = []

        # Translation parameters (to be inferred from mapping data)
        self.dimm_interleave_size = None
        self.col_increment = None
        self.row_increment = None
        self.ba_increment = None
        self.bg_increment = None
        self.rank_increment = None

        # System configuration (to be detected from data)
        self.num_dimms = 1
        self.num_ranks = 1
        self.num_bg = 4
        self.num_ba = 4
        self.max_row = 0
        self.max_col = 0

        if mapping_file and not mock_mode:
            self._load_mapping_data(mapping_file)
            self._infer_translation_rules()
        elif mock_mode:
            self._init_mock_translation()

    def _load_mapping_data(self, csv_file: str):
        """Load DPA mapping data from CSV file"""
        with open(csv_file, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                self.mapping_data.append({
                    'dpa': int(row['dpa']),
                    'subch': int(row['subch']),
                    'dimm': int(row['dimm']),
                    'rank': int(row['rank']),
                    'bg': int(row['bg']),
                    'ba': int(row['ba']),
                    'row': int(row['row']),
                    'col': int(row['col'])
                })

        print(f"Loaded {len(self.mapping_data)} mapping samples from {csv_file}")

    def _infer_translation_rules(self):
        """
        Infer translation rules from mapping data

        This analyzes the collected mapping data to determine:
        1. Interleaving granularity (DIMM, rank, bank)
        2. Address bit mapping
        3. Sequential access patterns
        """
        if len(self.mapping_data) < 10:
            raise ValueError("Not enough mapping data to infer translation rules")

        # Detect system configuration
        self.num_dimms = len(set(e['dimm'] for e in self.mapping_data))
        self.num_ranks = len(set(e['rank'] for e in self.mapping_data))
        self.num_bg = len(set(e['bg'] for e in self.mapping_data))
        self.num_ba = len(set(e['ba'] for e in self.mapping_data))
        self.max_row = max(e['row'] for e in self.mapping_data)
        self.max_col = max(e['col'] for e in self.mapping_data)

        print(f"Detected configuration:")
        print(f"  DIMMs: {self.num_dimms}")
        print(f"  Ranks: {self.num_ranks}")
        print(f"  Bank Groups: {self.num_bg}")
        print(f"  Banks: {self.num_ba}")
        print(f"  Max Row: 0x{self.max_row:x}")
        print(f"  Max Col: 0x{self.max_col:x}")

        # Find increment patterns
        self._find_dimm_interleave()
        self._find_col_increment()
        self._find_row_increment()
        self._find_bank_increments()

        print(f"\nInferred translation rules:")
        if self.dimm_interleave_size:
            print(f"  DIMM interleave: {self.dimm_interleave_size} bytes (0x{self.dimm_interleave_size:x})")
        if self.col_increment:
            print(f"  Column increment: {self.col_increment} bytes (0x{self.col_increment:x})")
        if self.row_increment:
            print(f"  Row increment: {self.row_increment} bytes (0x{self.row_increment:x})")
        if self.ba_increment:
            print(f"  Bank increment: {self.ba_increment} bytes (0x{self.ba_increment:x})")
        if self.bg_increment:
            print(f"  Bank Group increment: {self.bg_increment} bytes (0x{self.bg_increment:x})")

    def _find_dimm_interleave(self):
        """Find DIMM interleaving granularity"""
        for i in range(1, len(self.mapping_data)):
            prev = self.mapping_data[i-1]
            curr = self.mapping_data[i]

            if (curr['dimm'] != prev['dimm'] and
                curr['row'] == prev['row'] and
                curr['col'] == prev['col'] and
                curr['ba'] == prev['ba'] and
                curr['bg'] == prev['bg']):
                delta = curr['dpa'] - prev['dpa']
                if self.dimm_interleave_size is None or delta < self.dimm_interleave_size:
                    self.dimm_interleave_size = delta

    def _find_col_increment(self):
        """Find column increment in DPA"""
        for i in range(1, len(self.mapping_data)):
            prev = self.mapping_data[i-1]
            curr = self.mapping_data[i]

            if (curr['col'] != prev['col'] and
                curr['row'] == prev['row'] and
                curr['ba'] == prev['ba'] and
                curr['bg'] == prev['bg'] and
                curr['dimm'] == prev['dimm']):
                delta = curr['dpa'] - prev['dpa']
                col_delta = curr['col'] - prev['col']
                if col_delta > 0:
                    increment = delta // col_delta
                    if self.col_increment is None or increment < self.col_increment:
                        self.col_increment = increment

    def _find_row_increment(self):
        """Find row increment in DPA"""
        for i in range(1, len(self.mapping_data)):
            prev = self.mapping_data[i-1]
            curr = self.mapping_data[i]

            if (curr['row'] != prev['row'] and
                curr['ba'] == prev['ba'] and
                curr['bg'] == prev['bg'] and
                curr['dimm'] == prev['dimm']):
                delta = curr['dpa'] - prev['dpa']
                row_delta = curr['row'] - prev['row']
                if row_delta > 0:
                    increment = delta // row_delta
                    if self.row_increment is None or increment < self.row_increment:
                        self.row_increment = increment

    def _find_bank_increments(self):
        """Find bank and bank group increments"""
        for i in range(1, len(self.mapping_data)):
            prev = self.mapping_data[i-1]
            curr = self.mapping_data[i]

            # Bank increment
            if (curr['ba'] != prev['ba'] and
                curr['bg'] == prev['bg'] and
                curr['dimm'] == prev['dimm']):
                delta = curr['dpa'] - prev['dpa']
                if self.ba_increment is None or delta < self.ba_increment:
                    self.ba_increment = delta

            # Bank group increment
            if (curr['bg'] != prev['bg'] and
                curr['dimm'] == prev['dimm']):
                delta = curr['dpa'] - prev['dpa']
                if self.bg_increment is None or delta < self.bg_increment:
                    self.bg_increment = delta

    def _init_mock_translation(self):
        """Initialize translation rules based on actual 128GB CMM-D mapping"""
        # Actual mapping rules from GNR-CRB measurements
        # Based on docs/DPA_MAPPING_RULES.md
        self.dimm_interleave_size = 0x40      # 64B per DIMM
        self.bg_increment = 0x80              # 128B per BG
        self.col_increment = 0x400            # 1KB per Column
        self.ba_increment = 0x20000           # 128KB per BA
        self.subch_increment = 0x80000        # 512KB per Subchannel
        self.row_increment = 0x100000         # 1MB per Row

        self.num_subch = 2
        self.num_dimms = 2
        self.num_ranks = 1
        self.num_bg = 8
        self.num_ba = 4
        self.max_row = 0x1FFFF  # 128GB device
        self.max_col = 0x7FF    # 2048 columns (0-0x7ff)

        print("[MOCK] Using actual 128GB CMM-D translation rules")

    def dpa_to_dram(self, dpa: int) -> Dict:
        """
        Forward translation: DPA → DRAM address

        Args:
            dpa: Device Physical Address

        Returns:
            Dictionary with DRAM address components:
            {'subch': int, 'dimm': int, 'rank': int,
             'bg': int, 'ba': int, 'row': int, 'col': int}
        """
        if self.mock_mode:
            return self._mock_dpa_to_dram(dpa)

        # TODO: Implement based on inferred rules
        # For now, search in mapping data (slow, but accurate)
        for entry in self.mapping_data:
            if entry['dpa'] == dpa:
                return {
                    'subch': entry['subch'],
                    'dimm': entry['dimm'],
                    'rank': entry['rank'],
                    'bg': entry['bg'],
                    'ba': entry['ba'],
                    'row': entry['row'],
                    'col': entry['col']
                }

        # If not found, try to extrapolate
        raise NotImplementedError("DPA not in mapping data, extrapolation not yet implemented")

    def dram_to_dpa(self, rank: int, bg: int, ba: int, row: int, col: int,
                   dimm: int = 0, subch: int = 0) -> int:
        """
        Reverse translation: DRAM address → DPA

        This is the KEY function for March algorithm implementation.

        Args:
            rank, bg, ba, row, col: DRAM address components
            dimm: DIMM number (default: 0)
            subch: Subchannel number (default: 0)

        Returns:
            Device Physical Address (DPA)
        """
        if self.mock_mode:
            return self._mock_dram_to_dpa(rank, bg, ba, row, col, dimm, subch)

        # TODO: Implement based on inferred rules
        # For now, search in mapping data
        for entry in self.mapping_data:
            if (entry['rank'] == rank and
                entry['bg'] == bg and
                entry['ba'] == ba and
                entry['row'] == row and
                entry['col'] == col and
                entry['dimm'] == dimm and
                entry['subch'] == subch):
                return entry['dpa']

        # If not found, try to calculate using inferred rules
        if self._can_calculate_reverse():
            return self._calculate_dpa(rank, bg, ba, row, col, dimm, subch)

        raise ValueError(f"Cannot translate DRAM address to DPA: "
                        f"rank={rank} bg={bg} ba={ba} row={row} col={col} "
                        f"dimm={dimm} subch={subch}")

    def _can_calculate_reverse(self) -> bool:
        """Check if we have enough information for reverse calculation"""
        return all([
            self.col_increment is not None,
            self.row_increment is not None,
            self.ba_increment is not None,
            self.bg_increment is not None
        ])

    def _calculate_dpa(self, rank: int, bg: int, ba: int, row: int, col: int,
                      dimm: int, subch: int) -> int:
        """
        Calculate DPA from DRAM address using actual mapping rules

        Formula (128GB CMM-D):
        DPA = row × 0x100000 +
              subch × 0x80000 +
              ba × 0x20000 +
              col × 0x400 +
              bg × 0x80 +
              dimm × 0x40
        """
        dpa = 0

        # Layer 6: Row (1MB per row)
        if self.row_increment:
            dpa += row * self.row_increment

        # Layer 5: Subchannel (512KB per subchannel)
        if hasattr(self, 'subch_increment') and self.subch_increment:
            dpa += subch * self.subch_increment

        # Layer 4: BA (128KB per BA)
        if self.ba_increment:
            dpa += ba * self.ba_increment

        # Layer 3: Column (1KB per column)
        if self.col_increment:
            dpa += col * self.col_increment

        # Layer 2: BG (128B per BG)
        if self.bg_increment:
            dpa += bg * self.bg_increment

        # Layer 1: DIMM (64B per DIMM)
        if self.dimm_interleave_size:
            dpa += dimm * self.dimm_interleave_size

        # Rank is always 0 for this device

        return dpa

    def _mock_dpa_to_dram(self, dpa: int) -> Dict:
        """Forward translation using actual mapping rules"""
        # Hierarchical extraction (from largest to smallest)
        row = dpa // 0x100000
        dpa_in_row = dpa % 0x100000

        subch = dpa_in_row // 0x80000
        dpa_in_subch = dpa_in_row % 0x80000

        ba = dpa_in_subch // 0x20000
        dpa_in_ba = dpa_in_subch % 0x20000

        col = dpa_in_ba // 0x400
        dpa_in_col = dpa_in_ba % 0x400

        bg = dpa_in_col // 0x80
        dpa_in_bg = dpa_in_col % 0x80

        dimm = dpa_in_bg // 0x40

        return {
            'subch': subch,
            'dimm': dimm,
            'rank': 0,
            'bg': bg,
            'ba': ba,
            'row': row,
            'col': col
        }

    def _mock_dram_to_dpa(self, rank: int, bg: int, ba: int, row: int, col: int,
                         dimm: int, subch: int) -> int:
        """Reverse translation using actual mapping rules"""
        # Actual formula based on 128GB CMM-D
        dpa = 0
        dpa += row * 0x100000    # Layer 6: Row (1MB)
        dpa += subch * 0x80000   # Layer 5: Subchannel (512KB)
        dpa += ba * 0x20000      # Layer 4: BA (128KB)
        dpa += col * 0x400       # Layer 3: Column (1KB)
        dpa += bg * 0x80         # Layer 2: BG (128B)
        dpa += dimm * 0x40       # Layer 1: DIMM (64B)
        return dpa

    def validate_translation(self, sample_size: int = 100) -> float:
        """
        Validate translation accuracy using mapping data

        Tests forward and reverse translation consistency.

        Args:
            sample_size: Number of samples to test

        Returns:
            Accuracy percentage (0.0 - 100.0)
        """
        if not self.mapping_data:
            print("No mapping data to validate")
            return 0.0

        correct = 0
        total = min(sample_size, len(self.mapping_data))

        for i in range(total):
            entry = self.mapping_data[i]

            try:
                # Test reverse translation
                calculated_dpa = self.dram_to_dpa(
                    entry['rank'], entry['bg'], entry['ba'],
                    entry['row'], entry['col'],
                    entry['dimm'], entry['subch']
                )

                if calculated_dpa == entry['dpa']:
                    correct += 1
                else:
                    if i < 10:  # Print first few errors
                        print(f"Mismatch: expected DPA 0x{entry['dpa']:x}, "
                              f"got 0x{calculated_dpa:x}")
            except Exception as e:
                if i < 10:
                    print(f"Error: {e}")

        accuracy = (correct / total) * 100
        print(f"\nTranslation validation: {correct}/{total} correct ({accuracy:.1f}%)")

        return accuracy
