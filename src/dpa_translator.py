"""
DPA Translator - Bidirectional DPA ↔ DRAM Address Translation

This module provides translation between Device Physical Address (DPA)
and DRAM address components (rank, bank group, bank, row, column).
"""

import csv
import json
from typing import Dict, Optional, List, Tuple


class DPATranslator:
    """
    Bidirectional DPA ↔ DRAM address translation

    Forward:  DPA → (subch, dimm, rank, bg, ba, row, col)
    Reverse:  (rank, bg, ba, row, col, dimm, subch) → DPA

    The reverse translation is critical for implementing March algorithms
    that require sequential DRAM cell access.
    """

    def __init__(self, mapping_file: Optional[str] = None, mock_mode: bool = False):
        """
        Initialize DPA translator

        Args:
            mapping_file: CSV file containing DPA mapping data from umxc
                         (generated by dpa_mapping_collector.py)
            mock_mode: If True, use simplified mock translation rules
        """
        self.mock_mode = mock_mode
        self.mapping_data: List[Dict] = []

        # Translation parameters (to be inferred from mapping data)
        self.dimm_interleave_size = None
        self.col_increment = None
        self.row_increment = None
        self.ba_increment = None
        self.bg_increment = None
        self.rank_increment = None

        # System configuration (to be detected from data)
        self.num_dimms = 1
        self.num_ranks = 1
        self.num_bg = 4
        self.num_ba = 4
        self.max_row = 0
        self.max_col = 0

        if mapping_file and not mock_mode:
            self._load_mapping_data(mapping_file)
            self._infer_translation_rules()
        elif mock_mode:
            self._init_mock_translation()

    def _load_mapping_data(self, csv_file: str):
        """Load DPA mapping data from CSV file"""
        with open(csv_file, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                self.mapping_data.append({
                    'dpa': int(row['dpa']),
                    'subch': int(row['subch']),
                    'dimm': int(row['dimm']),
                    'rank': int(row['rank']),
                    'bg': int(row['bg']),
                    'ba': int(row['ba']),
                    'row': int(row['row']),
                    'col': int(row['col'])
                })

        print(f"Loaded {len(self.mapping_data)} mapping samples from {csv_file}")

    def _infer_translation_rules(self):
        """
        Infer translation rules from mapping data

        This analyzes the collected mapping data to determine:
        1. Interleaving granularity (DIMM, rank, bank)
        2. Address bit mapping
        3. Sequential access patterns
        """
        if len(self.mapping_data) < 10:
            raise ValueError("Not enough mapping data to infer translation rules")

        # Detect system configuration
        self.num_dimms = len(set(e['dimm'] for e in self.mapping_data))
        self.num_ranks = len(set(e['rank'] for e in self.mapping_data))
        self.num_bg = len(set(e['bg'] for e in self.mapping_data))
        self.num_ba = len(set(e['ba'] for e in self.mapping_data))
        self.max_row = max(e['row'] for e in self.mapping_data)
        self.max_col = max(e['col'] for e in self.mapping_data)

        print(f"Detected configuration:")
        print(f"  DIMMs: {self.num_dimms}")
        print(f"  Ranks: {self.num_ranks}")
        print(f"  Bank Groups: {self.num_bg}")
        print(f"  Banks: {self.num_ba}")
        print(f"  Max Row: 0x{self.max_row:x}")
        print(f"  Max Col: 0x{self.max_col:x}")

        # Find increment patterns
        self._find_dimm_interleave()
        self._find_col_increment()
        self._find_row_increment()
        self._find_bank_increments()

        print(f"\nInferred translation rules:")
        if self.dimm_interleave_size:
            print(f"  DIMM interleave: {self.dimm_interleave_size} bytes (0x{self.dimm_interleave_size:x})")
        if self.col_increment:
            print(f"  Column increment: {self.col_increment} bytes (0x{self.col_increment:x})")
        if self.row_increment:
            print(f"  Row increment: {self.row_increment} bytes (0x{self.row_increment:x})")
        if self.ba_increment:
            print(f"  Bank increment: {self.ba_increment} bytes (0x{self.ba_increment:x})")
        if self.bg_increment:
            print(f"  Bank Group increment: {self.bg_increment} bytes (0x{self.bg_increment:x})")

    def _find_dimm_interleave(self):
        """Find DIMM interleaving granularity"""
        for i in range(1, len(self.mapping_data)):
            prev = self.mapping_data[i-1]
            curr = self.mapping_data[i]

            if (curr['dimm'] != prev['dimm'] and
                curr['row'] == prev['row'] and
                curr['col'] == prev['col'] and
                curr['ba'] == prev['ba'] and
                curr['bg'] == prev['bg']):
                delta = curr['dpa'] - prev['dpa']
                if self.dimm_interleave_size is None or delta < self.dimm_interleave_size:
                    self.dimm_interleave_size = delta

    def _find_col_increment(self):
        """Find column increment in DPA"""
        for i in range(1, len(self.mapping_data)):
            prev = self.mapping_data[i-1]
            curr = self.mapping_data[i]

            if (curr['col'] != prev['col'] and
                curr['row'] == prev['row'] and
                curr['ba'] == prev['ba'] and
                curr['bg'] == prev['bg'] and
                curr['dimm'] == prev['dimm']):
                delta = curr['dpa'] - prev['dpa']
                col_delta = curr['col'] - prev['col']
                if col_delta > 0:
                    increment = delta // col_delta
                    if self.col_increment is None or increment < self.col_increment:
                        self.col_increment = increment

    def _find_row_increment(self):
        """Find row increment in DPA"""
        for i in range(1, len(self.mapping_data)):
            prev = self.mapping_data[i-1]
            curr = self.mapping_data[i]

            if (curr['row'] != prev['row'] and
                curr['ba'] == prev['ba'] and
                curr['bg'] == prev['bg'] and
                curr['dimm'] == prev['dimm']):
                delta = curr['dpa'] - prev['dpa']
                row_delta = curr['row'] - prev['row']
                if row_delta > 0:
                    increment = delta // row_delta
                    if self.row_increment is None or increment < self.row_increment:
                        self.row_increment = increment

    def _find_bank_increments(self):
        """Find bank and bank group increments"""
        for i in range(1, len(self.mapping_data)):
            prev = self.mapping_data[i-1]
            curr = self.mapping_data[i]

            # Bank increment
            if (curr['ba'] != prev['ba'] and
                curr['bg'] == prev['bg'] and
                curr['dimm'] == prev['dimm']):
                delta = curr['dpa'] - prev['dpa']
                if self.ba_increment is None or delta < self.ba_increment:
                    self.ba_increment = delta

            # Bank group increment
            if (curr['bg'] != prev['bg'] and
                curr['dimm'] == prev['dimm']):
                delta = curr['dpa'] - prev['dpa']
                if self.bg_increment is None or delta < self.bg_increment:
                    self.bg_increment = delta

    def _init_mock_translation(self):
        """Initialize mock translation rules (for testing without real data)"""
        # Simplified mock rules based on typical DRAM organization
        self.dimm_interleave_size = 64  # 64B cache line
        self.col_increment = 128  # 2 cache lines per column
        self.row_increment = 8192  # 128 columns * 64B
        self.ba_increment = 262144  # 4KB rows * 64B
        self.bg_increment = 1048576  # 4 banks * 256KB

        self.num_dimms = 2
        self.num_ranks = 1
        self.num_bg = 4
        self.num_ba = 4
        self.max_row = 0x7fff
        self.max_col = 0x3ff

        print("[MOCK] Using simplified translation rules")

    def dpa_to_dram(self, dpa: int) -> Dict:
        """
        Forward translation: DPA → DRAM address

        Args:
            dpa: Device Physical Address

        Returns:
            Dictionary with DRAM address components:
            {'subch': int, 'dimm': int, 'rank': int,
             'bg': int, 'ba': int, 'row': int, 'col': int}
        """
        if self.mock_mode:
            return self._mock_dpa_to_dram(dpa)

        # TODO: Implement based on inferred rules
        # For now, search in mapping data (slow, but accurate)
        for entry in self.mapping_data:
            if entry['dpa'] == dpa:
                return {
                    'subch': entry['subch'],
                    'dimm': entry['dimm'],
                    'rank': entry['rank'],
                    'bg': entry['bg'],
                    'ba': entry['ba'],
                    'row': entry['row'],
                    'col': entry['col']
                }

        # If not found, try to extrapolate
        raise NotImplementedError("DPA not in mapping data, extrapolation not yet implemented")

    def dram_to_dpa(self, rank: int, bg: int, ba: int, row: int, col: int,
                   dimm: int = 0, subch: int = 0) -> int:
        """
        Reverse translation: DRAM address → DPA

        This is the KEY function for March algorithm implementation.

        Args:
            rank, bg, ba, row, col: DRAM address components
            dimm: DIMM number (default: 0)
            subch: Subchannel number (default: 0)

        Returns:
            Device Physical Address (DPA)
        """
        if self.mock_mode:
            return self._mock_dram_to_dpa(rank, bg, ba, row, col, dimm, subch)

        # TODO: Implement based on inferred rules
        # For now, search in mapping data
        for entry in self.mapping_data:
            if (entry['rank'] == rank and
                entry['bg'] == bg and
                entry['ba'] == ba and
                entry['row'] == row and
                entry['col'] == col and
                entry['dimm'] == dimm and
                entry['subch'] == subch):
                return entry['dpa']

        # If not found, try to calculate using inferred rules
        if self._can_calculate_reverse():
            return self._calculate_dpa(rank, bg, ba, row, col, dimm, subch)

        raise ValueError(f"Cannot translate DRAM address to DPA: "
                        f"rank={rank} bg={bg} ba={ba} row={row} col={col} "
                        f"dimm={dimm} subch={subch}")

    def _can_calculate_reverse(self) -> bool:
        """Check if we have enough information for reverse calculation"""
        return all([
            self.col_increment is not None,
            self.row_increment is not None,
            self.ba_increment is not None,
            self.bg_increment is not None
        ])

    def _calculate_dpa(self, rank: int, bg: int, ba: int, row: int, col: int,
                      dimm: int, subch: int) -> int:
        """
        Calculate DPA from DRAM address using inferred rules

        This is a simplified calculation that may need refinement
        based on actual hardware behavior.
        """
        dpa = 0

        # Add column contribution
        if self.col_increment:
            dpa += col * self.col_increment

        # Add row contribution
        if self.row_increment:
            dpa += row * self.row_increment

        # Add bank contribution
        if self.ba_increment:
            dpa += ba * self.ba_increment

        # Add bank group contribution
        if self.bg_increment:
            dpa += bg * self.bg_increment

        # Add DIMM interleaving
        if self.dimm_interleave_size and dimm > 0:
            dpa += dimm * self.dimm_interleave_size

        # TODO: Add rank contribution when detected

        return dpa

    def _mock_dpa_to_dram(self, dpa: int) -> Dict:
        """Mock forward translation for testing"""
        # Simplified mock logic
        dimm = (dpa // self.dimm_interleave_size) % self.num_dimms
        remaining = dpa // (self.dimm_interleave_size * self.num_dimms)

        col = (remaining // self.col_increment) % (self.max_col + 1)
        row = (remaining // self.row_increment) % (self.max_row + 1)
        ba = (remaining // self.ba_increment) % self.num_ba
        bg = (remaining // self.bg_increment) % self.num_bg

        return {
            'subch': 0,
            'dimm': dimm,
            'rank': 0,
            'bg': bg,
            'ba': ba,
            'row': row,
            'col': col
        }

    def _mock_dram_to_dpa(self, rank: int, bg: int, ba: int, row: int, col: int,
                         dimm: int, subch: int) -> int:
        """Mock reverse translation for testing"""
        dpa = 0
        dpa += col * self.col_increment
        dpa += row * self.row_increment
        dpa += ba * self.ba_increment
        dpa += bg * self.bg_increment
        dpa += dimm * self.dimm_interleave_size
        return dpa

    def validate_translation(self, sample_size: int = 100) -> float:
        """
        Validate translation accuracy using mapping data

        Tests forward and reverse translation consistency.

        Args:
            sample_size: Number of samples to test

        Returns:
            Accuracy percentage (0.0 - 100.0)
        """
        if not self.mapping_data:
            print("No mapping data to validate")
            return 0.0

        correct = 0
        total = min(sample_size, len(self.mapping_data))

        for i in range(total):
            entry = self.mapping_data[i]

            try:
                # Test reverse translation
                calculated_dpa = self.dram_to_dpa(
                    entry['rank'], entry['bg'], entry['ba'],
                    entry['row'], entry['col'],
                    entry['dimm'], entry['subch']
                )

                if calculated_dpa == entry['dpa']:
                    correct += 1
                else:
                    if i < 10:  # Print first few errors
                        print(f"Mismatch: expected DPA 0x{entry['dpa']:x}, "
                              f"got 0x{calculated_dpa:x}")
            except Exception as e:
                if i < 10:
                    print(f"Error: {e}")

        accuracy = (correct / total) * 100
        print(f"\nTranslation validation: {correct}/{total} correct ({accuracy:.1f}%)")

        return accuracy
